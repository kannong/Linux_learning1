一、字节序：
1、小字节序：低位存低地址
2、大字节序：低位存高地址

二、C程序编译过程
程序——预处理（hello.i）——编译（hello.s）——汇编（hello.o）——链接（hello）

1、gcc -E -o hello.i hello.c
       -E：只进行预处理
        预处理：包含头文件，展开宏定义
2、gcc -S -o hello.s hello.i
       -S：只进行编译
        编译：将.i文件翻译成汇编代码
3、gcc -c -o hello.o hello.S
       -c：只进行汇编和编译
       汇编：将.s文件转化成二进制机器码（ELF文件）
4、gcc -o  hello hello.o
       -o：链接
       链接：将.o文件转换成可执行程序


三、gcc编译器
1、基本编译指令
gcc -v
查看当前编译器版本
gcc -o hello  hello.c
输出指定文件名为hello的可执行文件
./hello
执行可执行程序

四、Makefile
执行Makefile文件——make

$(X) 表示X变量的值

1、规则
目标文件：可依赖文件
Tab   命令

当目标文件不存在或者依赖文件比目标文件要新

eg：
text:a.o b.o
       gcc -o a.o b.o
a.o:a.c：
       gcc -c -o a.c
b.o:b.c：
       gcc -c -o b.c

2、语法
make 目标
若不带目标则默认执行第一个

a.通配符：
%.o：包含所有文件
$@ ：表示所有目标文件
$< ：表示第一个依赖文件
$^ ：表示所有依赖文件

b.假想目标：.PHONY

c.变量
即时变量、延时变量、export
简单变量（即使变量）：
A := xxx      #A的值即刻确定，在定义时即确定
B = xxx       #B的值用到才确定

:=     #即时变量
=      #延时变量
?=     #延时变量，如果是第一次定义才起效，如果在前面该变量已定义则忽略这句
+=     #附加，它是即时变量还是延时变量取决于前面的定义

eg:
text：a.o b.o c.o
       gcc -o text $^
%.o：%.c 
       gcc -c -o $@ $<

d.Makefile函数
a. $(foreach var,list,text)       #将list中所有文件变为text格式
//B = $(foreach f,$(A),$(f).o)
b. $(filter pattern...,text)      # 在text中取出符合patten格式的值
   $(filter-out pattern...,text)  # 在text中取出不符合patten格式的值
//C = $(filter %.o,$(B))
//D = ab a.c b.c c.c
//E = $(filter-out %.c,$(D))

c. $(wildcard pattern)            # pattern定义了文件名的格式,
                                  # wildcard取出其中存在的文件
//F = $(wildcard %.c,$(D))

d. $(patsubst pattern,replacement,$(var))  # 从列表中取出每一个值
                                           # 如果符合pattern
						 # 则替换为replacement

e.Makefile深入学习
Makefile实例
a. 改进: 支持头文件依赖
http://blog.csdn.net/qq1452008/article/details/50855810

gcc -M c.c // 打印出依赖

gcc -M -MF c.d c.c  // 把依赖写入文件c.d

gcc -c -o c.o c.c -MD -MF c.d  // 编译c.o, 把依赖写入文件c.d

b. 添加CFLAGS
c. 分析裸板Makefile
